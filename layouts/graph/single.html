{{ define "main" }}
<div id="graph-container">
  <div id="graph-search">
    <input type="text" id="search-input" placeholder="Search notes... (press /)" autocomplete="off">
    <div id="search-results"></div>
  </div>
  <div id="graph-legend"></div>
  <div id="graph"></div>
  <div id="graph-info">
    <span id="node-count"></span> notes Â· <span id="edge-count"></span> connections
  </div>
  <div id="graph-tooltip"></div>
</div>

<div id="panel-overlay"></div>
<div id="content-panel">
  <div id="panel-header">
    <span id="panel-title"></span>
    <button id="panel-close" aria-label="Close panel">&times;</button>
  </div>
  <iframe id="panel-iframe"></iframe>
</div>

<style>
/* Break out of PaperMod's content container */
.main {
  max-width: 100% !important;
  padding: 0 !important;
}

.post-content {
  max-width: 100% !important;
}

#graph-container {
  position: relative;
  width: 100vw;
  height: calc(100vh - 100px);
  min-height: 600px;
  margin-left: calc(-50vw + 50%);
  background: var(--code-bg);
  overflow: hidden;
}

#graph {
  width: 100%;
  height: 100%;
}

/* Search UI */
#graph-search {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 50;
  width: 280px;
}

#search-input {
  width: 100%;
  padding: 8px 12px;
  font-size: 0.9rem;
  background: var(--entry);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--primary);
  outline: none;
  transition: border-color 0.15s, box-shadow 0.15s;
}

#search-input:focus {
  border-color: var(--link);
  box-shadow: 0 0 0 2px rgba(var(--link-rgb, 59, 130, 246), 0.2);
}

#search-input::placeholder {
  color: var(--secondary);
}

#search-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--entry);
  border: 1px solid var(--border);
  border-radius: 6px;
  margin-top: 4px;
  max-height: 300px;
  overflow-y: auto;
  display: none;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

#search-results.open {
  display: block;
}

.search-result {
  padding: 8px 12px;
  cursor: pointer;
  border-bottom: 1px solid var(--border);
  transition: background 0.1s;
}

.search-result:last-child {
  border-bottom: none;
}

.search-result:hover,
.search-result.selected {
  background: var(--code-bg);
}

.search-result-title {
  font-weight: 500;
  color: var(--primary);
}

.search-result-category {
  font-size: 0.8rem;
  color: var(--secondary);
  margin-top: 2px;
}

/* Legend */
#graph-legend {
  position: absolute;
  top: 10px;
  right: 10px;
  bottom: 40px;
  background: var(--entry);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 14px;
  font-size: 0.8rem;
  z-index: 50;
  overflow-y: auto;
}

.legend-title {
  font-weight: 600;
  color: var(--primary);
  margin-bottom: 8px;
  font-size: 0.85rem;
}

.legend-item {
  display: flex;
  align-items: center;
  margin-bottom: 4px;
  cursor: pointer;
  transition: opacity 0.15s;
}

.legend-item:hover {
  opacity: 0.7;
}

.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-right: 8px;
  flex-shrink: 0;
}

.legend-label {
  color: var(--secondary);
  white-space: nowrap;
}

#graph-info {
  position: absolute;
  bottom: 10px;
  left: 10px;
  font-size: 0.85rem;
  color: var(--secondary);
  background: var(--code-bg);
  padding: 4px 8px;
  border-radius: 4px;
  z-index: 10;
}

#graph-tooltip {
  position: absolute;
  padding: 8px 12px;
  background: var(--entry);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 0.9rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  max-width: 300px;
  z-index: 100;
}

.tooltip-category {
  font-size: 0.75rem;
  color: var(--secondary);
  margin-top: 4px;
}

/* Sliding panel */
#panel-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.4);
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.25s, visibility 0.25s;
  z-index: 200;
}

#panel-overlay.open {
  opacity: 1;
  visibility: visible;
}

#content-panel {
  position: fixed;
  top: 0;
  right: 0;
  width: 65%;
  max-width: 900px;
  height: 100vh;
  background: var(--theme);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
  transform: translateX(100%);
  transition: transform 0.3s ease-out;
  z-index: 300;
  display: flex;
  flex-direction: column;
}

#content-panel.open {
  transform: translateX(0);
}

#panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  background: var(--entry);
}

#panel-title {
  font-weight: 600;
  font-size: 1rem;
  color: var(--primary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#panel-close {
  background: none;
  border: none;
  font-size: 1.8rem;
  color: var(--secondary);
  cursor: pointer;
  padding: 0 8px;
  line-height: 1;
  transition: color 0.15s;
}

#panel-close:hover {
  color: var(--primary);
}

#panel-iframe {
  flex: 1;
  width: 100%;
  border: none;
  background: var(--theme);
}

/* Node states */
.node {
  cursor: pointer;
}

.node circle {
  stroke: var(--content);
  stroke-width: 1.5px;
  transition: fill 0.15s, stroke-width 0.15s;
}

.node:hover circle {
  stroke-width: 2.5px;
}

.node.highlighted circle {
  stroke-width: 2px;
}

.node.selected circle {
  stroke: #16a34a;
  stroke-width: 3px;
}

.node.dimmed circle {
  opacity: 0.2;
}

.node.search-match circle {
  stroke: #fbbf24;
  stroke-width: 3px;
}

/* Node labels */
.node-label {
  font-size: 10px;
  fill: var(--secondary);
  pointer-events: none;
  text-anchor: middle;
}

.node.selected .node-label,
.node.highlighted .node-label {
  fill: var(--primary);
  font-weight: 500;
}

.link {
  stroke: var(--border);
  stroke-opacity: 0.4;
  stroke-width: 1px;
  transition: stroke-opacity 0.15s, stroke-width 0.15s;
}

.link.highlighted {
  stroke: var(--primary);
  stroke-opacity: 0.8;
  stroke-width: 2px;
}

.link.selected {
  stroke: #22c55e;
  stroke-opacity: 0.9;
  stroke-width: 2px;
}

.link.dimmed {
  stroke-opacity: 0.1;
}

/* Mobile */
@media (max-width: 768px) {
  #content-panel {
    width: 100%;
  }

  #graph-legend {
    display: none;
  }

  #graph-search {
    width: calc(100% - 20px);
  }
}
</style>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
(async function() {
  const response = await fetch('/graph.json');
  const data = await response.json();

  document.getElementById('node-count').textContent = data.nodes.length;
  document.getElementById('edge-count').textContent = data.edges.length;

  const container = document.getElementById('graph');
  const tooltip = document.getElementById('graph-tooltip');
  const panel = document.getElementById('content-panel');
  const overlay = document.getElementById('panel-overlay');
  const iframe = document.getElementById('panel-iframe');
  const panelTitle = document.getElementById('panel-title');
  const panelClose = document.getElementById('panel-close');
  const searchInput = document.getElementById('search-input');
  const searchResults = document.getElementById('search-results');
  const legend = document.getElementById('graph-legend');

  const width = container.clientWidth;
  const height = container.clientHeight;

  let selectedNode = null;
  let searchMatches = [];
  let selectedSearchIndex = -1;
  let connectedNodes = []; // For Tab navigation
  let tabIndex = -1;

  // Generate consistent colors for any category using HSL
  const categoryColorCache = {};

  function stringToHue(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    return Math.abs(hash) % 360;
  }

  function getCategoryColor(category) {
    if (!category || category === 'Uncategorized') {
      return '#6b7280'; // gray for uncategorized
    }
    if (!categoryColorCache[category]) {
      const hue = stringToHue(category);
      categoryColorCache[category] = `hsl(${hue}, 70%, 55%)`;
    }
    return categoryColorCache[category];
  }

  // Build legend
  const categories = [...new Set(data.nodes.map(n => n.category))].sort();
  legend.innerHTML = '<div class="legend-title">Categories</div>';
  categories.forEach(cat => {
    const item = document.createElement('div');
    item.className = 'legend-item';
    item.innerHTML = `
      <span class="legend-color" style="background: ${getCategoryColor(cat)}"></span>
      <span class="legend-label">${cat.replace(/_/g, ' ')}</span>
    `;
    item.addEventListener('click', () => filterByCategory(cat));
    legend.appendChild(item);
  });

  // Create SVG
  const svg = d3.select('#graph')
    .append('svg')
    .attr('width', width)
    .attr('height', height)
    .attr('viewBox', [0, 0, width, height]);

  // Add zoom behavior with state persistence
  const g = svg.append('g');

  const zoom = d3.zoom()
    .extent([[0, 0], [width, height]])
    .scaleExtent([0.2, 4])
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
      saveViewportState(event.transform);
    });

  svg.call(zoom);

  // Restore viewport state immediately on load
  function restoreViewportState() {
    try {
      const saved = localStorage.getItem('graph-viewport');
      if (saved) {
        const { k, x, y } = JSON.parse(saved);
        const transform = d3.zoomIdentity.translate(x, y).scale(k);
        svg.call(zoom.transform, transform);
        return true;
      }
    } catch (e) {}
    return false;
  }

  function saveViewportState(transform) {
    try {
      localStorage.setItem('graph-viewport', JSON.stringify({
        k: transform.k,
        x: transform.x,
        y: transform.y
      }));
    } catch (e) {}
  }

  // Restore saved viewport immediately
  restoreViewportState();

  // Create node lookup for edges
  const nodeById = new Map(data.nodes.map(d => [d.id, d]));

  // Process edges to reference node objects
  const links = data.edges
    .filter(e => nodeById.has(e.source) && nodeById.has(e.target))
    .map(e => ({
      source: nodeById.get(e.source),
      target: nodeById.get(e.target)
    }));

  // Count connections per node for sizing
  const connectionCount = new Map();
  links.forEach(l => {
    connectionCount.set(l.source.id, (connectionCount.get(l.source.id) || 0) + 1);
    connectionCount.set(l.target.id, (connectionCount.get(l.target.id) || 0) + 1);
  });

  // Create simulation
  const simulation = d3.forceSimulation(data.nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(60))
    .force('charge', d3.forceManyBody().strength(-120))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide().radius(d => getRadius(d) + 2));

  // Draw links
  const link = g.append('g')
    .attr('class', 'links')
    .selectAll('line')
    .data(links)
    .join('line')
    .attr('class', 'link');

  // Draw nodes
  const node = g.append('g')
    .attr('class', 'nodes')
    .selectAll('g')
    .data(data.nodes)
    .join('g')
    .attr('class', 'node')
    .call(drag(simulation));

  function getRadius(d) {
    const count = connectionCount.get(d.id) || 1;
    return Math.min(4 + Math.sqrt(count) * 2, 16);
  }

  node.append('circle')
    .attr('r', d => getRadius(d))
    .attr('fill', d => getCategoryColor(d.category));

  // Add labels for highly-connected nodes (>15 connections)
  node.filter(d => (connectionCount.get(d.id) || 0) > 15)
    .append('text')
    .attr('class', 'node-label')
    .attr('dy', d => getRadius(d) + 12)
    .text(d => d.title.length > 20 ? d.title.slice(0, 18) + '...' : d.title);

  // Hover interactions
  node.on('mouseenter', (event, d) => {
    if (selectedNode && selectedNode.id === d.id) return;

    d3.select(event.currentTarget).classed('highlighted', true);
    link.classed('highlighted', l => l.source.id === d.id || l.target.id === d.id);

    const connected = new Set();
    links.forEach(l => {
      if (l.source.id === d.id) connected.add(l.target.id);
      if (l.target.id === d.id) connected.add(l.source.id);
    });
    node.filter(n => n.id !== selectedNode?.id).classed('highlighted', n => connected.has(n.id));

    tooltip.innerHTML = `<strong>${d.title}</strong><div class="tooltip-category">${d.category.replace(/_/g, ' ')}</div>`;
    tooltip.style.opacity = 1;
    tooltip.style.left = (event.pageX - container.getBoundingClientRect().left + 10) + 'px';
    tooltip.style.top = (event.pageY - container.getBoundingClientRect().top - 30) + 'px';
  });

  node.on('mouseleave', () => {
    node.filter(n => n.id !== selectedNode?.id).classed('highlighted', false);
    link.filter(l => !isSelectedLink(l)).classed('highlighted', false);
    tooltip.style.opacity = 0;
  });

  function isSelectedLink(l) {
    return selectedNode && (l.source.id === selectedNode.id || l.target.id === selectedNode.id);
  }

  // Click to open panel
  node.on('click', (event, d) => {
    event.stopPropagation();
    openPanel(d);
  });

  function openPanel(d) {
    selectedNode = d;
    tabIndex = -1;

    // Build connected nodes list for Tab navigation
    connectedNodes = [];
    links.forEach(l => {
      if (l.source.id === d.id) connectedNodes.push(l.target);
      if (l.target.id === d.id) connectedNodes.push(l.source);
    });

    // Update selection visuals
    node.classed('selected', n => n.id === d.id);
    link.classed('selected', l => l.source.id === d.id || l.target.id === d.id);

    // Open panel
    panelTitle.textContent = d.title;
    iframe.src = d.id + '/?embed=1';
    panel.classList.add('open');
    overlay.classList.add('open');
  }

  // Hide header/footer in iframe when loaded
  iframe.addEventListener('load', () => {
    try {
      const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
      const style = iframeDoc.createElement('style');
      style.textContent = `
        .nav, header.header, footer.footer, #local-graph-container, .post-nav-links { display: none !important; }
        .main { padding-top: 0 !important; }
        body { padding-top: 0 !important; }
      `;
      iframeDoc.head.appendChild(style);
    } catch (e) {
      // Cross-origin restriction, ignore
    }
  });

  function closePanel() {
    selectedNode = null;
    connectedNodes = [];
    tabIndex = -1;
    node.classed('selected', false);
    link.classed('selected', false);
    panel.classList.remove('open');
    overlay.classList.remove('open');
    iframe.src = '';
  }

  // Close handlers
  panelClose.addEventListener('click', closePanel);
  overlay.addEventListener('click', closePanel);

  // Search functionality
  function performSearch(query) {
    if (!query.trim()) {
      searchResults.classList.remove('open');
      searchMatches = [];
      selectedSearchIndex = -1;
      node.classed('search-match', false);
      node.classed('dimmed', false);
      link.classed('dimmed', false);
      return;
    }

    const lowerQuery = query.toLowerCase();
    searchMatches = data.nodes
      .filter(n => n.title.toLowerCase().includes(lowerQuery))
      .slice(0, 10);

    // Highlight matching nodes
    const matchIds = new Set(searchMatches.map(n => n.id));
    node.classed('search-match', n => matchIds.has(n.id));
    node.classed('dimmed', n => matchIds.size > 0 && !matchIds.has(n.id));
    link.classed('dimmed', l => matchIds.size > 0 && !matchIds.has(l.source.id) && !matchIds.has(l.target.id));

    // Update dropdown
    if (searchMatches.length > 0) {
      searchResults.innerHTML = searchMatches.map((n, i) => `
        <div class="search-result${i === selectedSearchIndex ? ' selected' : ''}" data-index="${i}">
          <div class="search-result-title">${n.title}</div>
          <div class="search-result-category">${n.category.replace(/_/g, ' ')}</div>
        </div>
      `).join('');
      searchResults.classList.add('open');

      // Click handlers
      searchResults.querySelectorAll('.search-result').forEach(el => {
        el.addEventListener('click', () => {
          const index = parseInt(el.dataset.index);
          zoomToNode(searchMatches[index]);
        });
      });
    } else {
      searchResults.classList.remove('open');
    }
  }

  function zoomToNode(targetNode) {
    // Find the D3 node
    const nodeData = data.nodes.find(n => n.id === targetNode.id);
    if (!nodeData || nodeData.x === undefined) return;

    // Zoom to the node
    const scale = 2;
    const transform = d3.zoomIdentity
      .translate(width / 2 - nodeData.x * scale, height / 2 - nodeData.y * scale)
      .scale(scale);

    svg.transition()
      .duration(500)
      .call(zoom.transform, transform);

    // Clear search
    searchInput.value = '';
    searchResults.classList.remove('open');
    searchMatches = [];
    selectedSearchIndex = -1;
    node.classed('search-match', false);
    node.classed('dimmed', false);
    link.classed('dimmed', false);

    // Open panel
    openPanel(nodeData);
  }

  searchInput.addEventListener('input', (e) => {
    selectedSearchIndex = -1;
    performSearch(e.target.value);
  });

  function filterByCategory(category) {
    const matches = data.nodes.filter(n => n.category === category);
    const matchIds = new Set(matches.map(n => n.id));

    node.classed('dimmed', n => !matchIds.has(n.id));
    link.classed('dimmed', l => !matchIds.has(l.source.id) && !matchIds.has(l.target.id));

    // Clear after 3 seconds
    setTimeout(() => {
      node.classed('dimmed', false);
      link.classed('dimmed', false);
    }, 3000);
  }

  // Keyboard navigation
  document.addEventListener('keydown', (e) => {
    // "/" to focus search
    if (e.key === '/' && document.activeElement !== searchInput) {
      e.preventDefault();
      searchInput.focus();
      return;
    }

    // Escape to close panel or clear search
    if (e.key === 'Escape') {
      if (searchInput.value) {
        searchInput.value = '';
        performSearch('');
        searchInput.blur();
      } else if (panel.classList.contains('open')) {
        closePanel();
      }
      return;
    }

    // Arrow navigation in search results
    if (document.activeElement === searchInput && searchMatches.length > 0) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedSearchIndex = Math.min(selectedSearchIndex + 1, searchMatches.length - 1);
        updateSearchSelection();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedSearchIndex = Math.max(selectedSearchIndex - 1, 0);
        updateSearchSelection();
      } else if (e.key === 'Enter' && selectedSearchIndex >= 0) {
        e.preventDefault();
        zoomToNode(searchMatches[selectedSearchIndex]);
      }
      return;
    }

    // Tab to cycle through connected nodes when panel is open
    if (e.key === 'Tab' && panel.classList.contains('open') && connectedNodes.length > 0) {
      e.preventDefault();
      if (e.shiftKey) {
        tabIndex = tabIndex <= 0 ? connectedNodes.length - 1 : tabIndex - 1;
      } else {
        tabIndex = (tabIndex + 1) % connectedNodes.length;
      }
      highlightTabNode(connectedNodes[tabIndex]);
    }

    // Enter to open highlighted node
    if (e.key === 'Enter' && tabIndex >= 0 && connectedNodes.length > 0) {
      openPanel(connectedNodes[tabIndex]);
    }
  });

  function updateSearchSelection() {
    searchResults.querySelectorAll('.search-result').forEach((el, i) => {
      el.classList.toggle('selected', i === selectedSearchIndex);
    });
    // Scroll into view
    const selectedEl = searchResults.querySelector('.search-result.selected');
    if (selectedEl) {
      selectedEl.scrollIntoView({ block: 'nearest' });
    }
  }

  function highlightTabNode(targetNode) {
    // Clear previous highlights
    node.classed('highlighted', false);

    // Highlight the target node
    node.filter(n => n.id === targetNode.id).classed('highlighted', true);

    // Show tooltip
    tooltip.innerHTML = `<strong>${targetNode.title}</strong><div class="tooltip-category">${targetNode.category.replace(/_/g, ' ')}</div>`;
    tooltip.style.opacity = 1;

    // Position tooltip near the node
    if (targetNode.x !== undefined) {
      const transform = d3.zoomTransform(svg.node());
      const screenX = targetNode.x * transform.k + transform.x + container.getBoundingClientRect().left;
      const screenY = targetNode.y * transform.k + transform.y + container.getBoundingClientRect().top;
      tooltip.style.left = (screenX - container.getBoundingClientRect().left + 10) + 'px';
      tooltip.style.top = (screenY - container.getBoundingClientRect().top - 30) + 'px';
    }
  }

  // Drag behavior
  function drag(simulation) {
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }
    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }
    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
    return d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended);
  }

  // Update positions on tick
  simulation.on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);
    node
      .attr('transform', d => `translate(${d.x},${d.y})`);
  });

  // Handle resize
  window.addEventListener('resize', () => {
    const newWidth = container.clientWidth;
    const newHeight = container.clientHeight;
    svg.attr('width', newWidth).attr('height', newHeight);
    simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
    simulation.alpha(0.3).restart();
  });
})();
</script>
{{ end }}
